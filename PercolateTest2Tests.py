#!/usr/bin/python
from unittest import TestCase   #, main
import unittest
from PercolateTest2 import *


class BagTests(TestCase):
    """ unit tests for bag class """

    def test_Bag(self):
        """ performs simple positive test case """
        expected = "{'city': 'Hayward', 'name': 'Akien'}"
        a = Bag(name="Akien", city="Hayward")
        actual = str(a)
        print "Expected: " + expected
        print "Actual:   " + actual
        print "Pass" if expected == actual else "Fail"
        assert expected == actual, "Match failed on " + actual


class ENoneUnitTest(TestCase):
    def test_enone_positive_001(self):
        a = ENone()
        assert a.number == 0, "Number was not zero"
        assert a.message == "OK", "Message was not OK"


class ENonePrintUsageUnitTest(TestCase):
    def test_print_usage_001(self):
        a = PrintUsage()
        assert a.number == 0, "Number was not zero"
        assert a.message == "OK", "Message was not OK"


class ERootExceptionUnitTest(TestCase):
    def test_simple_values(self):
        a = ERootException(1, "hi")
        assert a.number == 1, "number field was not valid, actual="+str(a.number)
        assert a.message == "hi", "message field was not valid, actual="+a.message


class EFileNotFoundUnitTest(TestCase):
    def test_FileNotFound(self):
        a = EFileNotFound(filename="foo")
        assert a.number == 3, "number field was not valid. expected: 3, actual: " + a.number
        message = "Error: File not found: foo"
        assert a.message == message, "message field was not valid. expected: %s, actual: %s" % (message, a.message)


class EInvalidArgumentsUnitTest(TestCase):
    def test_EInvalidArguments(self):
        a = EInvalidArguments(bad_arguments="foo")
        assert a.number == 3, "number field was not valid. expected: 3, actual: " + a.number
        message = "Error: File not found: foo"
        assert a.message == message, "message field was not valid. expected: %s, actual: %s" % (message, a.message)


class ProcessArgsUnitTest(TestCase):
    def __init__(self):
        self.num_pass = 0
        self.num_fail = 0
        self.result_data = ""
        super(ProcessArgsUnitTest, self).__init__()

    def RunOne(self, argstring, resultstring):
        global data_file_name
        global canonical_output_file
        global verbose_mode
        global test_mode
        global console_io
        data_file_name = None
        canonical_output_file = None
        verbose_mode = None
        test_mode = None
        console_io = None
        argslist = argstring.split(" ")
        try:
            ProcessArgs(argslist)
            raise ERootException(99, "Previous statement was expected to raise an exception but failed to do so")
        except ERootException as e:
            # because any ERootException could be generated by ProcessArgs
            pass
        result = [e, data_file_name, canonical_output_file, verbose_mode, test_mode, console_io]
        results = str(result)
        assert resultstring == results, "Failed to match: %s != %s" % (resultstring, results)

    def test_DashTAndBothFilesSpecifed(self):
        self.RunOne(sys.argv[0] + " -t canonical.in canonical.out", "[ENone(), 'canonical.in', 'canonical.out', True, True, False]")

    def test_DashTAndOneFileSpecified(self):
        self.RunOne(sys.argv[0] + " -t canonical", "[ENone(), 'canonical.in', 'canonical.out', True, True, False]")

    def test_DashTAndNoFilesSpecified(self):
        self.RunOne(sys.argv[0] + " -t", "[ENone(), None, None, True, True, True]")

    def test_DataInOnly(self):
        self.RunOne(sys.argv[0] + " data.in", "[ENone(), 'data.in', None, False, False, False]")

    def test_DashVAndDataIn(self):
        self.RunOne(sys.argv[0] + " -v data.in", "[ENone(), 'data.in', None, True, False, False]")


class FetchNextUnitTest(TestCase):
    def test_FetchNext(self):
        # it's beyond the scope of these unit tests to validate stdin
        global data_file_name
        canonical1 = "Noah, Moench, 123123121, 232 695 2394, yellow\n"
        canonical2 = "Ria Tillotson, aqua marine, 97671, 196 910 5548\n"
        data_file_name = "canonical.in"
        result_list = []
        result_count = 2
        for i in FetchNext():
            result_list.append(i)
            result_count -= 1
            if result_count == 0:
                break
        result1 = result_list[0]
        result2 = result_list[1]
        assert result1 == canonical1, "1 expected %s, actual %s" % (result1, canonical1)
        assert result1 == canonical2, "2 expected %s, actual %s" % (result2, canonical2)


class RegexFilterUnitTest(TestCase):

    def test_ShouldMatch(test_number, test):
        result = RegexFilter(test)
        assert test == result, "failed to match %s %s" % (test, result)

    def test_ShouldComeBackEmpty(test_number, test):
        result = RegexFilter(test)
        assert test == "", "some items not filtered (result should be empty. Actual: " + result

    def test_Digits(self):
        self.ShouldMatch(1, "123456789")

    def test_Lower(self):
        self.ShouldMatch(2, "abcdefghijklmnopqrstuvwxyz")

    def test_Upper(self):
        self.ShouldMatch(3, "ABCDEFGHIJKLMNOPQRSTUVWXYZ")

    def test_Special(self):
        self.ShouldMatch(4, " .,-")

    def test_ReservedSymbols1(self):
        self.ShouldComeBackEmpty(5, "\\\^\$\|\?\*\+\(\)\[\{")  # \^$|?*+()[{

    def test_ReservedSymbols1(self):
        self.ShouldComeBackEmpty(5, "`~!@#%&_=}]:;'\"<>/")


class NormalizeDataUnitTest(TestCase):
    def test_NormalizeData(self):
        def TestOne(test_number, line, result):
            test_result = NormalizeTheData(line)
            print "Test %i %s '%s', '%s'" % (test_number, "Pass" if (result == test_result) else "Fail", line, test_result)
            assert test_result == result, "Expected: %s, Actual: %s" % (test_result, result)

        TestOne(1, "a,b,1234567890 ", ['a', 'b', '1234567890'])
        TestOne(2, " a, b, 12345 67890 ", ['a', 'b', '1234567890'])


print __name__
if __name__ == '__main__':
    unittest.main()

